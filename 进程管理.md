# ps 进程状态

### 相关实例

```shell
#查看进程的PID
ps axo pid
#查看进程的名称
ps axo comm
#查看进程的CPU占用率
ps axo pcpu
#按内存资源的使用量对进程，从大到小
ps aux | sort -rnk 4
#按CPU资源的使用量对进程排序，从小到大
ps aux | sort -nk 3
#显示所有进程信息
ps -A
#显示指定用户的进程信息
ps -u root
#查看线程数
ps -efL
#查看进程并按内存使用大小排序
ps -e -o "%C : %p : %z : %a" | sort -k5 -nr
#显示所有进程信息，连同终端
ps -ef
#ps与grep常用组合，查找指定进程
ps -ef | grep ssh
#通过名字或者命令搜索进程
ps -C nginx
#CPU或者内存进行排序， -降序，+升序
ps aux --sort=-pcpu
ps aux --sort=+pmem
#用树的风格显示进程的层次关系
ps -f --forest -C nginx
#显示一个父进程的子进程
ps -o pid,uname,comm -C nginx
#重定义标签
ps -eo pid,uname=USERNAME,pcpu=CPU_USAGE,pmem=MEMUSAGE,comm
#显示进程运行的时间
ps -eo pid,comm,etime
#查看named进程详细信息
ps -aux | grep ssh
#通过进程id获取服务名称
ps -o command -p 91730 | sed -n 2p
#找出与cron和 syslog这两个服务有关的PID号码
ps aux | egrep '(cron|syslog)'
```

### TLDR

```shell
  ps

  Information about running processes.
  More information: https://manned.org/ps.

  - List all running processes:
    ps aux

  - List all running processes including the full command string:
    ps auxww

  - Search for a process that matches a string:
    ps aux | grep string

  - List all processes of the current user in extra full format:
    ps --user $(id -u) -F

  - List all processes of the current user as a tree:
    ps --user $(id -u) f

  - Get the parent PID of a process:
    ps -o ppid= -p pid

  - Sort processes by memory consumption:
    ps --sort size
```



# pstree 树状查看进程

### 实例

```shell
#显示当前所有进程和进程ID
pstree -p
#显示所有进程的详细信息
pstree -a
#获取SSH会话的PID
pstree -a | grep ssh
```

### TLDR

```shell
  pstree

  A convenient tool to show running processes as a tree.
  More information: https://manned.org/pstree.

  - Display a tree of processes:
    pstree

  - Display a tree of processes with PIDs:
    pstree -p

  - Display all process trees rooted at processes owned by specified user:
    pstree user
```



# top 实时系统状态

## TLDR

```shell
  #top的界面是一个交互界面，可以按h进入帮助模式
  top

  Display dynamic real-time information about running processes.
  More information: https://manned.org/top.

  - Start top:
    top

  - Do not show any idle or zombie processes:
    top -i

  - Show only processes owned by given user:
    top -u username

  - Sort processes by a field:
    top -o field_name

  - Show the individual threads of a given process:
    top -Hp process_id

  - Show only the processes with the given PID(s), passed as a comma-separated list. (Normally you wouldn't know PIDs off hand. This example picks the PIDs from the process name):
    top -p $(pgrep -d ',' process_name)

  - Get help about interactive commands:
    ?
```



# 控制台关键字含义

## ps aux

```shell
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
```

| 关键字  | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| USER    | 进程所有者                                                   |
| PID     | 进程id                                                       |
| %CPU    | 进程所占用的CPU资源百分比                                    |
| %MEM    | 进程所占用的内存资源百分比                                   |
| VSZ     | 进程占用的虚拟内存量                                         |
| RSS     | 进程占用的固定内存量                                         |
| TTY     | 运行进程的终端机，若与终端机无关则为？，tty1-tty6是本机上面的登入程序，若为pts/0则为网络连接 |
| STAT    | 进程的运行状态                                               |
| STAT:R  | TASK_RUNNING,可执行状态                                      |
| STAT:S  | TASK_INTERRUPTIBLE,可中断的睡眠状态                          |
| STAT:D  | TASK_UNINTERRUPTIBLE，不可中断的睡眠状态                     |
| STAT:T  | TASK_TRACED,暂停状态或跟踪状态                               |
| STAT:Z  | TASK_DEAD-EXIT_ZOMBIE,退出状态，进程成为僵尸进程             |
| STAT:X  | TASK_DEAD-EXIT_DEAD，退出状态，进程即将被销毁                |
| START   | 进程被启动的时间                                             |
| TIME    | 进程实际占用CPU的时间                                        |
| COMMAND | 进程所属的指令                                               |



## ps -el

```shell
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
```

| 关键字 | 含义                            |
| ------ | ------------------------------- |
| F      | 进程的flag                      |
| S      | 进程的状态                      |
| UID    | 进程所属的用户                  |
| PID    | 进程的id                        |
| PPID   | 父进程的id                      |
| C      | 占用的CPU比例                   |
| PRI    | PRIORITY值，进程优先级          |
| NI     | NICE值                          |
| ADDR   | 进程在内存中的位置              |
| SZ     | 进程占用的内存值                |
| WCHAN  | 进程是否正在运行，-表示正在运行 |
| TTY    | 登入者的终端机位置              |
| TIME   | 进程占用的CPU时间               |
| CMD    | 进程所属的指令                  |



## top

```shell
top - 16:48:37 up 13:53,  1 user,  load average: 0.01, 0.08, 0.05
Tasks: 117 total,   2 running,  72 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  4032776 total,  1944028 free,   194292 used,  1894456 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  3567388 avail Mem 

```

| 关键字                                                       | 含义                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| top - 16:48:37                                               | 当前系统时间                                                 |
| up 13:53                                                     | 系统运行时间                                                 |
| 1 user                                                       | 当前登录用户数                                               |
| load average: 0.01, 0.08, 0.05                               | 1min, 5min, 15min内的平均CPU负载                             |
| Tasks: 117 total,  2 running, 72 sleeping,  0 stopped,  0 zombie | 进程数量：总进程数，正在运行进程数，休眠进程数，停止进程数，僵尸进程数 |
| %Cpu(s): 0.2 us, 0.2 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st | CPU占用：当前用户占用(user space)，内核空间占用(sysctl)，    |
|                                                              | 改变过优先级的进程占用(nice priority)，空闲百分比(idolt)，IO等待占用(wait)， |
|                                                              | 硬中断占用(hardware interrupts)，软中断占比(software interupts) |
| KiB Mem : 4032776 total, 1944028 free,  194292 used, 1894456 buff/cache | 内存状态：总计，空闲，已用，缓存                             |
| KiB Swap:    0 total,    0 free,    0 used. 3567388 avail Mem | swap交换分区状态：总计，空闲，已用，缓存                     |



```shell
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND  
```

| 关键字  | 含义         |
| ------- | ------------ |
| PID     | PID          |
| USER    | 所属用户     |
| PR      | 进程优先级   |
| NI      | nice优先值   |
| VIRT    | 虚拟内存占用 |
| RES     | 物理内存占用 |
| SHR     | 共享内存占用 |
| S       | 进程状态     |
| %CPU    | CPU占比      |
| %MEM    | 物理内存占比 |
| TIME+   | 运行的时长   |
| COMMAND | 运行的命令   |



# nice 指定优先级给将运行的程序

## 实例

```shell
#nice 范围从-20 到 19 ，值越⼩优先级越⾼，抢占资源就越多
nice -n 10 ./a.sh
```

## TLDR

```shell
  nice

  Execute a program with a custom scheduling priority (niceness).
  Niceness values range from -20 (the highest priority) to 19 (the lowest).
  More information: https://www.gnu.org/software/coreutils/nice.

  - Launch a program with altered priority:
    nice -n niceness_value command
```



# renice 修改运行中的进程的优先级

## 实例

```shell
#将pid为19314的进程的优先级提升15
renice -n 15 19314
```

## TLDR

```shell
  renice

  Alters the scheduling priority/nicenesses of one or more running processes.
  Niceness values range from -20 (most favorable to the process) to 19 (least favorable to the process).
  More information: https://manned.org/renice.

  - Change priority of a running process:
    renice -n niceness_value -p pid

  - Change priority of all processes owned by a user:
    renice -n niceness_value -u user

  - Change priority of all processes that belong to a process group:
    renice -n niceness_value --pgrp process_group
```



# jobs 查看作业状态

## 实例

```shell
#首先运行一个ssh程序产生一个作业
ssh 192.168.1.1
#之后按下CTRL + Z使作业移交后台处理
#再后台执行一个睡眠程序
sleep 60 &
#查看正在运行的作业，带pid
jobs -l
#将编号为2的后台作业移交前台
fg 2
#将编号为2的前台作业移交后台
bg 2
```



## TLDR

```shell
  jobs

  BASH builtin for viewing information about processes spawned by the current shell.
  More information: https://manned.org/jobs.

  - View jobs spawned by the current shell:
    jobs

  - List jobs and their process IDs:
    jobs -l

  - Display information about jobs with changed status:
    jobs -n

  - Display process ID of process group leader:
    jobs -p

  - Display running processes:
    jobs -r

  - Display stopped processes:
    jobs -s
```



# kill 结束进程

## 实例

```shell
#查看kill的信号列表
kill -l
#常用的kill信号，只有SIGKILL可以无条件终止，其他信号进程都有权利忽略
HUP		1	终端挂断
INT		2	终端，效果等同CTRL+C
QUIT	3	退出，效果等同CTRL+\
KILL	9	强制终止
TERM	15	终止
CONT	18	继续，与STOP相反，fg/bg命令
STOP	19	暂停，效果等同CTRL+Z
#杀死指定进程
kill -9 12345
```

## TLDR

```SHELL
  kill

  Sends a signal to a process, usually related to stopping the process.
  All signals except for SIGKILL and SIGSTOP can be intercepted by the process to perform a clean exit.
  More information: https://manned.org/kill.

  - Terminate a program using the default SIGTERM (terminate) signal:
    kill process_id

  - List available signal names (to be used without the `SIG` prefix):
    kill -l

  - Terminate a background job:
    kill %job_id

  - Terminate a program using the SIGHUP (hang up) signal. Many daemons will reload instead of terminating:
    kill -1|HUP process_id

  - Terminate a program using the SIGINT (interrupt) signal. This is typically initiated by the user pressing `Ctrl + C`:
    kill -2|INT process_id

  - Signal the operating system to immediately terminate a program (which gets no chance to capture the signal):
    kill -9|KILL process_id

  - Signal the operating system to pause a program until a SIGCONT ("continue") signal is received:
    kill -17|STOP process_id

  - Send a `SIGUSR1` signal to all processes with the given GID (group id):
    kill -SIGUSR1 -group_id

```



# nohup 后台运行程序

## 实例

```shell
#不做挂断操作，后台下载，终端操作无效
nohup wget www.site.com/file.zip
#挂断操作，后台下载，终端操作有效
nohup wget www.site.com/file.zip &
#下面的命令会在后台持续ping，输出的ping信息在/root/nohup.out文件中
nohup ping www.baidu.com &
#下面的命令指定了输出的信息位置
nohup ping www.baidu.com > /root/ping.txt &
nohup ping www.baidu.com > /root/ping.txt 2>&1 &
```

## TLDR

```shell
  nohup

  Allows for a process to live when the terminal gets killed.
  More information: https://www.gnu.org/software/coreutils/nohup.

  - Run a process that can live beyond the terminal:
    nohup command command_arguments

  - Launch nohup in background mode:
    nohup command command_arguments &

  - Run a shell script that can live beyond the terminal:
    nohup path/to/script.sh &

  - Run a process and write the output to a specific file:
    nohup command command_arguments > path/to/output_file &

```



# screen 命令行后台切换

## 实例

```shell
#新建一个名为robotinx的session
screen -S robotinx
#列出当前所有的session
screen -ls
#回到robotinx这个session
screen -r robotinx
#断开指定的session
screen -d robotinx
#断开当前的session并回到指定的session
screen -dr robotinx
```

## TLDR

```shell
  screen

  Hold a session open on a remote server. Manage multiple windows with a single SSH connection.
  See also `tmux` and `zellij`.
  More information: https://manned.org/screen.

  - Start a new screen session:
    screen

  - Start a new named screen session:
    screen -S session_name

  - Start a new daemon and log the output to `screenlog.x`:
    screen -dmLS session_name command

  - Show open screen sessions:
    screen -ls

  - Reattach to an open screen:
    screen -r session_name

  - Detach from inside a screen:
    Ctrl + A, D

  - Kill the current screen session:
    Ctrl + A, K

  - Kill a detached screen:
    screen -X -S session_name quit
```

# 常用的日志记录

```shell
/var/log/messages
/var/log/dmesg
/var/log/secure
/var/log/cron
```

# service 服务管理工具

## 实例

```shell
#旧版的服务管理工具
#相关的配置都放在/etc/init.d文件夹下
#可以通过chkconfig --list查询
```

## TLDR

```shell
  service

  Manage services by running init scripts.
  The full script path should be omitted (`/etc/init.d/` is assumed).
  More information: https://manned.org/service.

  - List the name and status of all services:
    service --status-all

  - Start/Stop/Restart/Reload service (start/stop should always be available):
    service service_name start|stop|restart|reload

  - Do a full restart (runs script twice with start and stop):
    service service_name --full-restart

  - Show the current status of a service:
    service service_name status
```



# chkconfig 设置系统服务

## 运行等级

```shell
/etc/inittab
0 halt 关机
1 single user mode 单用户模式
2 multiuser 多用户，无网络功能
3 full multiuser 多用户 有网络功能
4 unused 未定义
5 x11 图形桌面坏境
6 reboot 重启
```

## 增加一个服务

```shell
#服务脚本必须存放在/etc/ini.d/目录下；
#在chkconfig工具服务列表中增加此服务，此时服务会被在/etc/rc.d/rcN.d中赋予K/S入口
chkconfig --add servicename
#修改服务的默认启动等级
chkconfig --level 35 mysqld on
```

## 运行级文件

>每个被chkconfig管理的服务需要在对应的init.d下的脚本加上两行或者更多行的注释。
>
>第一行告诉chkconfig缺省启动的运行级以及启动和停止的优先级。
>
>如果某服务缺省不在任何运行级启动，那么使用-代替运行级。第二行对服务进行描述，可以用\跨行注释。
>
>例如random.init包含三行：

```shell
# chkconfig: 2345 20 80
# description: Saves and restores system entropy pool for \
# higher quality random number generation.
```

## 实例

```shell
#列出所有的系统服务
chkconfig --list
#增加httpd服务
chkconfig --add httpd
#删除httpd服务
chkconfig --del httpd
#设置httpd在运行级别2345的情况下都是on
chkconfig --level httpd 2345 on
#列出httpd服务设置情况
chkconfig --list httpd
#设置httpd在各运行级别都为on
chkconfig httpd on
```

## TLDR

```shell
  chkconfig

  Manage the runlevel of services on CentOS 6.
  More information: https://manned.org/chkconfig.

  - List services with runlevel:
    chkconfig --list

  - Show a service's runlevel:
    chkconfig --list ntpd

  - Enable service at boot:
    chkconfig sshd on

  - Enable service at boot for runlevels 2, 3, 4, and 5:
    chkconfig --level 2345 sshd on

  - Disable service at boot:
    chkconfig ntpd off

  - Disable service at boot for runlevel 3:
    chkconfig --level 3 ntpd off
```



# systemctl 服务管理工具

## systemctl

| 任务                 | 旧指令                        | 新指令                              |
| -------------------- | ----------------------------- | ----------------------------------- |
| 使某项服务自动启动   | chkconfig --level 3 httpd on  | systemctl enable httpd.service      |
| 使某项服务不自动启动 | chkconfig --level 3 httpd off | systemctl disable httpd.service     |
| 检查服务状态         | service httpd status          | systemctl status httpd.service      |
| 显示所有已启动的服务 | chkconfig --list              | systemctl list-units --type=service |
| 启动服务             | service httpd start           | systemctl start httpd.service       |
| 停止服务             | service httpd stop            | systemctl stop httpd.service        |
| 重启服务             | service httpd restart         | systemctl restart httpd.service     |
| 重载服务             | service httpd reload          | systemctl reload httpd.service      |

## 实例

```shell
#启动nfs服务
systemctl start nfs.service
#设置开机自启动
systemctl enable nfs.service
#关闭开机自启动
systemctl disable nfs.service
#查看服务的当前状态
sytemctl status nfs.service
#重启启动某项服务
systemctl restart nfs.service
#查看所有已启动的服务
systemctl list-units --type=service
```

## TLDR

```shell
  systemctl

  Control the systemd system and service manager.
  More information: https://www.freedesktop.org/software/systemd/man/systemctl.html.

  - Show all running services:
    systemctl status

  - List failed units:
    systemctl --failed

  - Start/Stop/Restart/Reload a service:
    systemctl start|stop|restart|reload unit

  - Show the status of a unit:
    systemctl status unit

  - Enable/Disable a unit to be started on bootup:
    systemctl enable|disable unit

  - Mask/Unmask a unit to prevent enablement and manual activation:
    systemctl mask|unmask unit

  - Reload systemd, scanning for new or changed units:
    systemctl daemon-reload

  - Check if a unit is enabled:
    systemctl is-enabled unit
```

# 服务所在文件夹

## 相关文件

```shell
#两个旧版的网络相关的服务
/etc/init.d/netconsole
/etc/init.d/network
#新版服务所在文件夹
/usr/lib/sytemd/system
```

## 服务文件配置实例

```shell
#打开sshd服务的配置文件
vim /usr/lib/systemd/system/sshd.service

[Unit]
Description=OpenSSH server daemon
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target sshd-keygen.service
Wants=sshd-keygen.service
[Service]
Type=notify
EnvironmentFile=/etc/sysconfig/sshd
ExecStart=/usr/sbin/sshd -D $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=42s
[Install]
WantedBy=multi-user.target
```

## 服务运行级别映射

```shell
#服务运行级别映射映射
ls -l /usr/lib/systemd/system/runlevel*.target

lrwxrwxrwx 1 root root 15 Mar 24 19:41 runlevel0.target -> poweroff.target
lrwxrwxrwx 1 root root 13 Mar 24 19:41 runlevel1.target -> rescue.target
lrwxrwxrwx 1 root root 17 Mar 24 19:41 runlevel2.target -> multi-user.target
lrwxrwxrwx 1 root root 17 Mar 24 19:41 runlevel3.target -> multi-user.target
lrwxrwxrwx 1 root root 17 Mar 24 19:41 runlevel4.target -> multi-user.target
lrwxrwxrwx 1 root root 16 Mar 24 19:41 runlevel5.target -> graphical.target
lrwxrwxrwx 1 root root 13 Mar 24 19:41 runlevel6.target -> reboot.target
```



# SELinux

```shell
#查看SELinux状态的命令
getenforce
/usr/sbin/sestatus
#临时关闭SELinux
setenforce 0
#SELinux配置文件
/etc/selinux/config
#配置中关闭SELinux
SELINUX=disabled
```

