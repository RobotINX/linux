# 文本操作

## 元字符

- 主要的元字符

  ```shell
  () #标记子表达式的开头和结尾
  {} #标记限定符表达式的开头和结尾
  . #除换行符以外的所有字符。
  ^ #字符串开头。
  $ #字符串结尾。
  \d,\w,\s #匹配数字、字符、空格。
  \D,\W,\S #匹配非数字、非字符、非空格。
  [abc] #匹配 a、b 或 c 中的一个字母。
  [a-z] #匹配 a 到 z 中的一个字母。
  [^abc] #匹配除了 a、b 或 c 中的其他字母。
  aa|bb #匹配 aa 或 bb。
  ? #0 次或 1 次匹配。
  * #匹配 0 次或多次。
  + #匹配 1 次或多次。
  {n} #匹配 n次。
  {n,} #匹配 n次以上。
  {m,n} #最少 m 次，最多 n 次匹配。
  (expr) #捕获 expr 子模式,以 \1 使用它。
  (?:expr) #忽略捕获的子模式。
  (?=expr) #正向预查模式 expr。
  (?!expr) #负向预查模式 expr。
  ```

- 简单示例

  ```shell
  #匹配以一个或多个数字开头，以abc结尾的字符串
  /^[0-9]+abc$/
  #匹配以小写字母、数字、-和_组成的长度为3-15的字符串
  /^[a-z0-9-_]{3,15}$/
  #匹配任意长度的正整数
  /^[1-9][0-9]*/
  #匹配1-99的正整数
  /^[1-9][0-9]?/
  /[1-9][0-9]{0,1}/
  #贪婪匹配<>
  /<.*>/
      <h1>runoob.com</h1>
  #最小匹配<>
  /<.*?>/
      <h1>
      </h1>
  #匹配以Chapter开头，两位数结尾的字符
  /^Chapter [1-9][0-9]$?/
  ```



## read 读取标准输入

- 实例

  ```shell
  #普通输入
  read var
  echo $var
  #带提示
  read -p "please enter a character:" var
  echo $var
  #-t 参数指定 read 命令等待输入的秒数，当计时满时，read命令返回一个非零退出状态
  read -t 5 -p "please enter a character in 5 seconds:" var
  echo $var
  ```

- TLDR

  ```shell
    read
  
    BASH builtin for retrieving data from standard input.
    More information: https://manned.org/read.1p.
  
    - Store data that you type from the keyboard:
      read variable
  
    - Store each of the next lines you enter as values of an array:
      read -a array
  
    - Specify the number of maximum characters to be read:
      read -n character_count variable
  
    - Use a specific character as a delimiter instead of a new line:
      read -d new_delimiter variable
  
    - Do not let backslash (\) act as an escape character:
      read -r variable
  
    - Display a prompt before the input:
      read -p "Enter your input here: " variable
  
    - Do not echo typed characters (silent mode):
      read -s variable
  
    - Read stdin and perform an action on every line:
      while read line; do echo "$line"; done
  ```



## find 文件搜索

- 一般用法

- TLDR

  ```shell
    find
  
    Find files or directories under the given directory tree, recursively.
    More information: https://manned.org/find.
  
    - Find files by extension:
      find root_path -name '*.ext'
  
    - Find files matching multiple path/name patterns:
      find root_path -path '**/path/**/*.ext' -or -name '*pattern*'
  
    - Find directories matching a given name, in case-insensitive mode:
      find root_path -type d -iname '*lib*'
  
    - Find files matching a given pattern, excluding specific paths:
      find root_path -name '*.py' -not -path '*/site-packages/*'
  
    - Find files matching a given size range:
      find root_path -size +500k -size -10M
  
    - Run a command for each file (use `{}` within the command to access the filename):
      find root_path -name '*.ext' -exec wc -l {} \;
  
    - Find files modified in the last 7 days and delete them:
      find root_path -daystart -mtime -7 -delete
  
    - Find empty (0 byte) files and delete them:
      find root_path -type f -empty -delete
  ```

  

## grep 文本搜索

- REGEXP

  ```shell
  ^    	# 锚定行的开始 如：'^grep'匹配所有以grep开头的行。    
  $    	# 锚定行的结束 如：'grep$' 匹配所有以grep结尾的行。
  .    	# 匹配非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。    
  *    	# 匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。    
  .*   	# 一起用代表任意字符。   
  []   	# 匹配指定范围内的字符，如'[Gg]rep'匹配Grep和grep。    
  [^]  	# 匹配在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的字母开头，紧跟rep的行。 
  \(..\)  # 标记匹配字符，如'\(love\)'，love被标记为1。    
  \<      # 锚定单词的开始，如:'\<grep'匹配包含以grep开头的单词的行。    
  \>      # 锚定单词的结束，如'grep\>'匹配包含以grep结尾的单词的行。    
  x\{m\}  # 重复字符x，m次，如：'0\{5\}'匹配包含5个o的行。    
  x\{m,\} # 重复字符x,至少m次，如：'o\{5,\}'匹配至少有5个o的行。    
  x\{m,n\}# 重复字符x，至少m次，不多于n次，如：'o\{5,10\}'匹配5--10个o的行。   
  \w    	# 匹配文字和数字字符，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。   
  \W    	# \w的反置形式，匹配一个或多个非单词字符，如点号句号等。   
  \b    	# 单词锁定符，如: '\bgrep\b'只匹配grep。 
  ```

- 常见用法

  ```shell
  #从文本中搜索root所在的行
  grep root passwd
  #从文本中搜索没有root的行
  grep -v root passwd
  #输出文本中有root的行数
  grep -c root passwd
  #带行标输出带有root的行
  grep -n root passwd
  #带坐标输出带有root的行
  grep -nb root passwd
  ```

- TLDR

  ```shell
    grep
  
    Find patterns in files using regular expressions.
    More information: https://www.gnu.org/software/grep/manual/grep.html.
  
    - Search for a pattern within a file:
      grep "search_pattern" path/to/file
  
    - Search for an exact string (disables regular expressions):
      grep --fixed-strings "exact_string" path/to/file
  
    - Search for a pattern in all files recursively in a directory, showing line numbers of matches, ignoring binary files:
      grep --recursive --line-number --binary-files=without-match "search_pattern" path/to/directory
  
    - Use extended regular expressions (supports `?`, `+`, `{}`, `()` and `|`), in case-insensitive mode:
      grep --extended-regexp --ignore-case "search_pattern" path/to/file
  
    - Print 3 lines of context around, before, or after each match:
      grep --context|before-context|after-context=3 "search_pattern" path/to/file
  
    - Print file name and line number for each match:
      grep --with-filename --line-number "search_pattern" path/to/file
  
    - Search for lines matching a pattern, printing only the matched text:
      grep --only-matching "search_pattern" path/to/file
  
    - Search stdin for lines that do not match a pattern:
      cat path/to/file | grep --invert-match "search_pattern"
  ```




## sort 排序

- 实例

  ```shell
  #普通排序
  sort /etc/passwd
  #忽略相同行排序
  sort -u /etc/passwd
  #忽略字母，单独按照数字排序
  sort -n /etc/passwd
  #倒序
  sort -r /etc/passwd
  #指定第三列为关键字
  sort -k3 /etc/passwd
  #指定分隔符
  sort -t: /etc/passwd
  #从用户名的第二个字母开始排列
  sort -t: -k1.2 /etc/passwd
  #从用户名的第二个字母开始排列，如果相同则按照用户ID数字开始排列
  sort
  #分隔符为 ，以第三列数字倒序排列，如果相同，则以第二轮升序排序
  sort -t' '  -nr -k3 -k2 facebook.txt
  ```

- TLDR

  ```shell
    sort
  
    Sort lines of text files.
    More information: https://www.gnu.org/software/coreutils/sort.
  
    - Sort a file in ascending order:
      sort path/to/file
  
    - Sort a file in descending order:
      sort --reverse path/to/file
  
    - Sort a file in case-insensitive way:
      sort --ignore-case path/to/file
  
    - Sort a file using numeric rather than alphabetic order:
      sort --numeric-sort path/to/file
  
    - Sort `/etc/passwd` by the 3rd field of each line numerically, using ":" as a field separator:
      sort --field-separator=: --key=3n /etc/passwd
  
    - Sort a file preserving only unique lines:
      sort --unique path/to/file
  
    - Sort a file, printing the output to the specified output file (can be used to sort a file in-place):
      sort --output=path/to/file path/to/file
  
    - Sort numbers with exponents:
      sort --general-numeric-sort path/to/file
  ```

## cut 文本过滤

- 用法说明

  ```shell
  N-		#从第N个字符到结尾
  N-M		#从第N个字符到第M个字符
  -M		#从开始到第M个字符
  -b		#处理的是字节
  -c		#处理的是字符
  -f		#处理的是字段
  ```

- 一般用法

  ```shell
  #输出文件中的第三列
  cut -f3 passwd
  #指定分隔符号
  cut -f3 -d: passwd
  #输出文件中的第一第三列
  cut -f1,3 -d: passwd
  #输出文件中的第三列到第五列
  cut -f1-3 -d: passwd
  #输出文件中除了第四五六列的内容
  cut -f1,3 -d: --complement passwd
  #输出文件中的前三列内容
  cut -f-3 -d: passwd
  
  #输出文件中从第三列开始到最后一列的内容
  cut -f3- -d: passwd
  #输出每行中的第三到第五个字符
  cut -c3-5 passwd
  #输出每行中的第三个和第五个字符
  cut -c3,5 passwd
  #输出每行中的前五个字符
  cut -c-5 passwd
  #输出每行中从第三个开始到最后一个字符
  cut -c3- passwd
  ```

- TLDR

  ```shell
    cut
  
    Cut out fields from stdin or files.
    More information: https://www.gnu.org/software/coreutils/cut.
  
    - Cut out the first sixteen characters of each line of stdin:
      cut -c 1-16
  
    - Cut out the first sixteen characters of each line of the given files:
      cut -c 1-16 file
  
    - Cut out everything from the 3rd character to the end of each line:
      cut -c 3-
  
    - Cut out the fifth field of each line, using a colon as a field delimiter (default delimiter is tab):
      cut -d':' -f5
  
    - Cut out the 2nd and 10th fields of each line, using a semicolon as a delimiter:
      cut -d';' -f2,10
  
    - Cut out the fields 3 through to the end of each line, using a space as a delimiter:
      cut -d' ' -f3-
  
  ```

  

## sed 文本替换

### sed元字符集

```shell
^ # 匹配行开始，如：/^sed/匹配所有以sed开头的行。
$ # 匹配行结束，如：/sed$/匹配所有以sed结尾的行。
. # 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。
* # 匹配0个或多个字符，等价于{0,}，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。
[] # 匹配一个指定范围内的字符，如/[sS]ed/匹配sed和Sed。  
[^] # 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。
\(..\) # 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。
& # 保存搜索字符用来替换其他字符，如s/love/ **&** /，love这成 **love** 。
\< # 匹配单词的开始，如:/\<love/匹配包含以love开头的单词的行。
\> # 匹配单词的结束，如/love\>/匹配包含以love结尾的单词的行。
x\{m\} # 重复字符x，m次，如：/0\{5\}/匹配包含5个0的行。
x\{m,\} # 重复字符x，至少m次，如：/0\{5,\}/匹配至少有5个0的行。
x\{m,n\} # 重复字符x，至少m次，不多于n次，如：/0\{5,10\}/匹配5~10个0的行。 
```

### 打印模式：p

```shell
#每一行输出两次
sed 'p' passwd
#每一行输出一次
sed n '1p' passwd
#输出第一到三行
sed n '1,3p' passwd
#打印Jason所在行
sed -n '/Jason/p' passwd
#打印Jason至Jane所在行
sed -n '/Jason/,/Jane/p' passwd
#打印103开头的行
sed -n '/^103/p' passwd
#打印以manager结尾的行
sed -n '/manager$/p' passwd
#以连续三个数字开头的行
sed -n '/[^0-9]\{3\}/p' passwd
#从第一行开始打印，步长2
sed -n '1~2p' passwd
#从第二行开始打印，步长3
sed -n '2~3p' passwd
#打印uid为0或1的行
sed -n '/x:[0|1]:/p' passwd
```

### 替换操作：s

```shell
sed '[address-range|pattern-range] s/originalstring/replacement-string/[substitute-flags]' inputfile

#把每一行的：替换成-
sed 's/:/-/' /etc/passwd
#把所有的：替换成-
sed 's/:/-/g' /etc/passwd
#把文件中所有的：替换成-，结果写入文件
sed -i 's/:/-/g' /etc/passwd
#把文件中带有root的行整行删除
sed '/root/d' /etc/passwd
#把文件中所有的root都替换成---------
sed '/root/ s/root/---------/g' passwd
#多次匹配，把：和x替换成-
sed -e 's/:/-/g' -e 's/x/-/g' passwd
#把分隔符换成#
sed 's#:#-#g' passwd
#从第三个匹配到的字符开始替换
sed 's/:/-/3g' passwd
#把第二到第五行的manager替换成guozi
sed '2,5 s/manager/guozi/' passwd
#把john所在字符串的行里的manager替换成guozi
sed '/john/ s/manager/guozi/' passwd
#把第四行且包含字符串ram的行中，把developer替换成user
sed '4,/ram/ s/developer/user/' passwd
#把带有john的行，给john替换成[john]
sed 's/john/[&]/' passwd
#把以三个小写字母开头的行，加上{}
sed 's/^[a-z]\{3,\}/{&}/' passwd
#删除所有行的第一个字符
sed 's/^[a-z0-9]//' passwd
sed 's/^.//' passwd
#删除所有行的第三个字符
sed 's/.//3' passwd
#匹配所有的注释行中带#号的内容，把，后面的内容都删掉
sed '/#/ s/,.*//' passwd
#在每行的结尾加上#
sed 's/&/#/' passwd
#在ifconfig的信息中，找到各网卡对应的ipv4地址，并用{}标记
ifconfig | sed 's/\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}/{&}/'
```

### 删除操作：d

```shell
#删除空白行
sed '/^$/d' passwd
#删除文件的第二行
sed '2d' passwd
#删除文件第二行到末尾所有行
sed '2,$d' passwd
#删除第二行到第四行之外的所有行
sed '2，4!d' passwd
#删除文件最后一行
sed '$d' passwd
#删除文件中所有test开头的行
sed '/^test/d' passwd
#删除所有的注释和空白行
sed -e '/^$/d' -e '/^#.*/d' passwd
#附加行号并且删除第二到第五行
nl passwd | sed '2,5d' passwd
#删除从adm到最后一行
sed '/adm/,$d' passwd
#删除adm及其后一行
sed '/adm/,+1d' passwd
#删除1-5行中匹配root的行
sed '1,5{/root/d}' passwd
```

### 附加操作：a

```shell
sed '[address] a the-line-to-append' input-file
#在文件的第二行后加多一行------------------
sed '2 a ----------------' passwd
#在文件的最后一行后加多一行-----------------
sed '$ a ----------------' passwd
#在root所在行后加一行--------------
sed '/root/ a -------------' passwd
```

### 插入操作：i

```shell
sed '[address] i the-line-to-insert' input-file
#在文件的第二行前加多一行------------------
sed '2 i ----------------' passwd
#在文件的最后一行前加多一行-----------------
sed '$ i ----------------' passwd
#在root所在行前加一行--------------
sed '/root/ i -------------' passwd
```

### TLDR

```shell
  sed

  Edit text in a scriptable manner.
  More information: https://www.gnu.org/software/sed/manual/sed.html.

  - Replace the first occurrence of a regular expression in each line of a file, and print the result:
    sed 's/regular_expression/replace/' filename

  - Replace all occurrences of an extended regular expression in a file, and print the result:
    sed -r 's/regular_expression/replace/g' filename

  - Replace all occurrences of a string in a file, overwriting the file (i.e. in-place):
    sed -i 's/find/replace/g' filename

  - Replace only on lines matching the line pattern:
    sed '/line_pattern/s/find/replace/' filename

  - Delete lines matching the line pattern:
    sed '/line_pattern/d' filename

  - Print the first 11 lines of a file:
    sed 11q filename

  - Apply multiple find-replace expressions to a file:
    sed -e 's/find/replace/' -e 's/find/replace/' filename

  - Replace separator `/` by any other character not used in the find or replace patterns, e.g. `#`:
    sed 's#find#replace#' filename
```



## awk 文本和数据处理

```shell
cut -d : -f 1 /etc/passwd
awk -F: '/wd$/{print $1}' /etc/passwd
#找到端口为22的所有pid
netstat -antup | grep :22 | awk '{print $7}' | sed 's|/.\{0,\}||'
```

### 内置变量

- 说明

  ```shell
  NR			总行数 number of rows
  NF			总列数 number of fields
  $0			整行
  $1			第一列的数据
  $2			第二列的数据
  $NF			最后一列
  $(NF-1)		倒数第二列
  ```

- 实例

  ```shell
  #输出每一行的行标
  ps | awk '{print NR}'
  #输出每一行的总列数
  ps | awk '{print NF}'
  #输出一整行
  ps | awk '{print $0}'
  ps | awk '{print}'
  #输出每行的第一列
  ps | awk '{print $1}'
  #在每一行的前面附加当前行号和当前行的列数
  ps | awk '{print NR "\t" NF "\t" $0}'
  #输出每一行的最后一列
  ps | awk '{print $NF}'
  #输出每一行的倒数第二列
  ps | awk '{print $(NF-1)}'
  #输出每一行的第三列和第四列
  ps | awk '{print $3,$4}'
  ```

### 外部变量

- 实例

  ```shell
  VAR=1000
  echo | awk -v VARIABLE=$VAR '{print VARIABLE}'
  
  var1="aaa"
  var2="bbb"
  echo | awk '{print v1,v2}' v1=$var1 v2=$var2
  ```

### 运算和判断

- 实例

  ```shell
  #所用非操作数在用算数运算符操作时，自动转换为0
  #算术运算符有+ - * / &求余 !逻辑非 ^求幂 ++ --
  #赋值运算符= += -= *= /= %= ^=
  awk 'BEGIN{a="b"; print a++, ++a}'
  #||逻辑或 &&逻辑与
  awk 'BEGIN{a=1;b=2;print (a>5 && b<2), (a>5 || b<=2);}'
  #正则运算符 ~匹配 !~不匹配
  awk 'BEGIN{a="100testa"; if(a ~ /^100*/){print "ok";}}'
  #关系运算符 < <= > >= != ==
  awk 'BEGIN{a=11;if(a >= 9){print "ok";}}'
  awk 'BEGIN{a="b";print a=="b"?"ok":"err";}'
  awk 'BEGIN{a="a";arr[0]="b";arr[1]="c";print (a in arr);}'
  ```

### 高级输入输出



### TLDR

```shell
  awk

  A versatile programming language for working on files.
  More information: https://github.com/onetrueawk/awk.

  - Print the fifth column (a.k.a. field) in a space-separated file:
    awk '{print $5}' filename

  - Print the second column of the lines containing "foo" in a space-separated file:
    awk '/foo/ {print $2}' filename

  - Print the last column of each line in a file, using a comma (instead of space) as a field separator:
    awk -F ',' '{print $NF}' filename

  - Sum the values in the first column of a file and print the total:
    awk '{s+=$1} END {print s}' filename

  - Print every third line starting from the first line:
    awk 'NR%3==1' filename

  - Print different values based on conditions:
    awk '{if ($1 == "foo") print "Exact match foo"; else if ($1 ~ "bar") print "Partial match bar"; else print "Baz"}' filename

  - Print all lines where the 10th column value equals the specified value:
    awk '($10 == value)'

  - Print all the lines which the 10th column value is between a min and a max:
    awk '($10 >= min_value && $10 <= max_value)'
```



